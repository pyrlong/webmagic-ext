{"title":{"text":"<h2 id=\"t_58ae76e80100gcsa\" class=\"titName SG_txta\">分治算法的一点思考--为什么大多使用二分法？</h2>"},"content":{"text":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \">\n  &nbsp;\n <wbr />&nbsp;\n <wbr /> 分治思想在排序以及查找算法中使用广泛，如二分查找、归并排序、快速排序。我们知道这些算法的时间复杂度分别是Ο(log\n <font style=\"font-size: 10px;\">2</font>n)，Ο(nlog\n <font style=\"font-size: 10px;\">2</font>n),Ο(nlog\n <font style=\"font-size: 10px;\">2</font>n)，而底数2显然是因为使用了2分策略导致的。那么,假设我们使用3分甚至m分法，时间复杂度不就变成了Ο(log\n <font style=\"font-size: 10px;\">m</font>n)，Ο(nlog\n <font style=\"font-size: 10px;\">m</font>n),Ο(nlog\n <font style=\"font-size: 10px;\">m</font>n)，岂不是更快？\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> 这是一个很有迷惑性的想法。咋一看没什么错，但是仔细推敲，有2点考虑不周：\n <br /> 1、log\n <font style=\"font-size: 10px;\">m</font>n与log\n <font style=\"font-size: 10px;\">2</font>n的关系：log\n <font style=\"font-size: 10px;\">2</font>n/log\n <font style=\"font-size: 10px;\">m</font>n=log\n <font style=\"font-size: 10px;\">2</font>m。log\n <font style=\"font-size: 10px;\">2</font>m其实是一个常数，所以Ο(log\n <font style=\"font-size: 10px;\">2</font>n)与Ο(log\n <font style=\"font-size: 10px;\">m</font>n)是等价的，这也是估计时间复杂度时从来只用以2为底的对数的原因。\n <br /> 2、m分法很可能要花费更多的开销。例如：\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> 假设有一个2分查找binaryseek(A,p,r,n)，它以A[(p+r)/2]为比较对象，则每次递归需要进行1次比较：\n <br /> binaryseek(A,p,r,n)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> begin\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> if p==r{1} then output A[p]&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else begin\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> m :=(p+r)/2;\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> if n&lt;=A[m]{2} then binaryseek(A,p,m-1)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else if n==A[m]{3} then output A[m]\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else binaryseek(A,m+1,r)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> end\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> end\n <br /> 这个算法的时间复杂度为Ο(log\n <font style=\"font-size: 10px;\">2</font>n)，而实际最坏情况T(n) = 3T(log\n <font style=\"font-size: 10px;\">2</font>n)，期望时间为E(T)=2.5T(log\n <font style=\"font-size: 10px;\">2</font>n)。（记一次比较为T(1)）\n <br /> 如果改成3分呢？\n <br /> binaryseek(A,p,r,n)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> begin\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> if p==r{1} then output A[p]&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else begin\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> m1 :=(p+r)/3;\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> m2 :=(p+r)/3*2;\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> if n&lt;A[m1]{2} then binaryseek(A,p,m1-1)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else if n==A[m1]{3} then output A[m1]\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else begin\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> if n&lt;A[m2]{4} then\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> binaryseek(A,m1+1,m2-1)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else if n==A[m2]{5} then output A[m2]\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> else binaryseek(A,m2+1,r)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> end\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> end\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> 这个算法的时间复杂度仍旧为Ο(log\n <font style=\"font-size: 10px;\">2</font>n)，而实际最坏情况T(n) = 5T(log\n <font style=\"font-size: 10px;\">3</font>n)，期望时间为E(T)=3.667T\n <br /> (log\n <font style=\"font-size: 10px;\">3</font>n)。（记一次比较为T(1)）\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> 比较之下，发现3T(log\n <font style=\"font-size: 10px;\">2</font>n)&lt;5T(log\n <font style=\"font-size: 10px;\">3</font>n)，2.5T(log\n <font style=\"font-size: 10px;\">2</font>n)&lt;3.667T(log\n <font style=\"font-size: 10px;\">3</font>n)，可见二分法不但编写比较容易，在花费时间上也是较少的。\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> 那么m分法呢？可以估计最坏情况下，m分法要比较(m-1)*2+1次，列函数f(m)=((m-1)*2+1)/(3*log\n <font style=\"font-size: 10px;\">2</font>m)，可得f(m)递增，f(2) = 1。所以2分法要优于m分法。\n <br /> 另外想到一个有趣的题目：\n <br /> 如何写3分法的快速排序以及m分法的快速排序？\n <br /> 快速排序quicksort(A,p,r)的算法为：\n <br /> quicksort(A,p,r)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> if p&lt;r\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> m = partition(A,p,r)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> quicksort(A,p,m-1)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> quicksort(A,m+1,r)\n <br /> partition(A,p,r)过程如下:\n <br /> partition(A,p,r)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> q = p-1;\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr /> for (i = p;i&lt;r;i++)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> if (s[i]&lt;=s[r]) {\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> q++;\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> exchange(i,q)\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr /> }\n <br /> exchange(q+1,r)\n <br /> return q+1;\n <br /> &nbsp;\n <wbr /> 思想就是按照A[r]为标准将A一分为二，小于A[r]的在左边，大于A[r]的在右边。\n <br /> &nbsp;\n <wbr /> 那么三分法自然就可以取A[r-1]、A[r]作为标准了。这里可以先将A[r-1]、A[r]进行排序，将较小的放在前面这样比较的时候可以有效的减少次数。这样的话时间复杂度跟二分查找就类似了。T(m分法):T(2分法)=f(m)=((m-1)*2+1)/(3*log\n <font style=\"font-size: 10px;\">2</font>m)。\n <br /> &nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />&nbsp;\n <wbr />\n <br /> \n</div>"},"date":{"text":"2009-12-25 10:47:20"}}