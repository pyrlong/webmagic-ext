{"title":{"text":"<h2 id=\"t_58ae76e80100msy6\" class=\"titName SG_txta\">23个经典JDK设计模式</h2>"},"content":{"text":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \">\n  面是JDK中有关23个经典设计模式的示例： \n <p><strong><span style=\"text-decoration: underline;\">Structural（结构模式）</span></strong></p> \n <p><strong>Adapter:</strong></p> \n <p>把一个接口或是类变成另外一种。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Arrays#asList()</li> \n   <li>● javax.swing.JTable(TableModel)</li> \n   <li>● java.io.InputStreamReader(InputStream)</li> \n   <li>● java.io.OutputStreamWriter(OutputStream)</li> \n   <li>● javax.xml.bind.annotation.adapters.XmlAdapter#marshal()</li> \n   <li>● javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()</li> \n  </ul> \n </div> \n <p><strong>Bridge:</strong></p> \n <p>把抽象和实现解藕，于是接口和实现可在完全独立开来。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● AWT (提供了抽象层映射于实际的操作系统)</li> \n   <li>● JDBC</li> \n  </ul> \n </div> \n <p><strong>Composite:</strong></p> \n <p>让使用者把单独的对象和组合对象混用。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● javax.swing.JComponent#add(Component)</li> \n   <li>● java.awt.Container#add(Component)</li> \n   <li>● java.util.Map#putAll(Map)</li> \n   <li>● java.util.List#addAll(Collection)</li> \n   <li>● java.util.Set#addAll(Collection)</li> \n  </ul> \n </div> \n <p><strong>Decorator:</strong></p> \n <p> 为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。这个模式在JDK中几乎无处不在，所以，下面的列表只是一些典型的。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.io.BufferedInputStream(InputStream)</li> \n   <li>● java.io.DataInputStream(InputStream)</li> \n   <li>● java.io.BufferedOutputStream(OutputStream)</li> \n   <li>● java.util.zip.ZipOutputStream(OutputStream)</li> \n   <li>● java.util.Collections#checked[List|Map|Set|SortedSet|SortedMap]()</li> \n  </ul> \n </div> \n <p><strong>Facade:</strong></p> \n <p>用一个简单的接口包状一组组件，接口，抽象或是子系统。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.Class</li> \n   <li>● javax.faces.webapp.FacesServlet</li> \n  </ul> \n </div> \n <p><strong>Flyweight:</strong></p> \n <p>有效率地存储大量的小的对象。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.Integer#valueOf(int)</li> \n   <li>● java.lang.Boolean#valueOf(boolean)</li> \n   <li>● java.lang.Byte#valueOf(byte)</li> \n   <li>● java.lang.Character#valueOf(char)</li> \n  </ul> \n </div> \n <p><strong>Proxy:</strong></p> \n <p>用一个简单的对象来代替一个复杂的对象。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.reflect.Proxy</li> \n   <li>● RMI</li> \n  </ul> \n </div> \n <p><strong><span style=\"text-decoration: underline;\">Creational（创建模式）</span></strong></p> \n <p><strong>Abstract factory:</strong></p> \n <p> 创建一组有关联的对象实例。这个模式在JDK中也是相当的常见，还有很多的framework例如Spring。我们很容易找到这样的实例。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Calendar#getInstance()</li> \n   <li>● java.util.Arrays#asList()</li> \n   <li>● java.util.ResourceBundle#getBundle()</li> \n   <li>● java.sql.DriverManager#getConnection()</li> \n   <li>● java.sql.Connection#createStatement()</li> \n   <li>● java.sql.Statement#executeQuery()</li> \n   <li>● java.text.NumberFormat#getInstance()</li> \n   <li>● javax.xml.transform.TransformerFactory#newInstance()</li> \n  </ul> \n </div> \n <p><strong>Builder:</strong></p> \n <p>主要用来简化一个复杂的对象的创建。这个模式也可以用来实现一个&nbsp;<wbr /><a target=\"_blank\" href=\"http://en.wikipedia.org/wiki/Fluent_interface\">Fluent Interface</a>。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.StringBuilder#append()</li> \n   <li>● java.lang.StringBuffer#append()</li> \n   <li>● java.sql.PreparedStatement</li> \n   <li>● javax.swing.GroupLayout.Group#addComponent()</li> \n  </ul> \n </div> \n <p><strong>Factory:</strong></p> \n <p>简单来说，按照需求返回一个类型的实例。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.Proxy#newProxyInstance()</li> \n   <li>● java.lang.Object#toString()</li> \n   <li>● java.lang.Class#newInstance()</li> \n   <li>● java.lang.reflect.Array#newInstance()</li> \n   <li>● java.lang.reflect.Constructor#newInstance()</li> \n   <li>● java.lang.Boolean#valueOf(String)</li> \n   <li>● java.lang.Class#forName()</li> \n  </ul> \n </div> \n <p><strong>Prototype:</strong></p> \n <p> 使用自己的实例创建另一个实例。有时候，创建一个实例然后再把已有实例的值拷贝过去，是一个很复杂的动作。所以，使用这个模式可以避免这样的复杂性。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.Object#clone()</li> \n   <li>● java.lang.Cloneable</li> \n  </ul> \n </div> \n <p><strong>Singleton:</strong></p> \n <p>只允许一个实例。在 Effective Java中建议使用Emun.</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.Runtime#getRuntime()</li> \n   <li>● java.awt.Toolkit#getDefaultToolkit()</li> \n   <li>● java.awt.GraphicsEnvironment#getLocalGraphicsEnvironm<wbr />ent()</li> \n   <li>● java.awt.Desktop#getDesktop()</li> \n  </ul> \n </div> \n <p><strong><span style=\"text-decoration: underline;\">Behavioral(行为模式)</span></strong></p> \n <p><strong>Chain of responsibility:</strong></p> \n <p>把一个对象在一个链接传递直到被处理。在这个链上的所有的对象有相同的接口（抽象类）但却有不同的实现。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.logging.Logger#log()</li> \n   <li>● javax.servlet.Filter#doFilter()</li> \n  </ul> \n </div> \n <p><strong>Command:</strong></p> \n <p>把一个或一些命令封装到一个对象中。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.lang.Runnable</li> \n   <li>● javax.swing.Action</li> \n  </ul> \n </div> \n <p><strong>Interpreter:</strong></p> \n <p>一个语法解释器的模式。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Pattern</li> \n   <li>● java.text.Normalizer</li> \n   <li>● java.text.Format</li> \n  </ul> \n </div> \n <p><strong>Iterator:</strong></p> \n <p>提供一种一致的方法来顺序遍历一个容器中的所有元素。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Iterator</li> \n   <li>● java.util.Enumeration</li> \n  </ul> \n </div> \n <p><strong>Mediator:</strong></p> \n <p>用来减少对象单的直接通讯的依赖关系。使用一个中间类来管理消息的方向。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Timer</li> \n   <li>● java.util.concurrent.Executor#execute()</li> \n   <li>● java.util.concurrent.ExecutorService#submit()</li> \n   <li>● java.lang.reflect.Method#invoke()</li> \n  </ul> \n </div> \n <p><strong>Memento:</strong></p> \n <p>给一个对象的状态做一个快照。Date类在内部使用了一个long型来做这个快照。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Date</li> \n   <li>● java.io.Serializable</li> \n  </ul> \n </div> \n <p><strong>Null Object:</strong></p> \n <p>这个模式用来解决如果一个Collection中没有元素的情况。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Collections#emptyList()</li> \n   <li>● java.util.Collections#emptyMap()</li> \n   <li>● java.util.Collections#emptySet()</li> \n  </ul> \n </div> \n <p><strong>Observer:</strong></p> \n <p>允许一个对象向所有的侦听的对象广播自己的消息或事件。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.EventListener</li> \n   <li>● javax.servlet.http.HttpSessionBindingListen<wbr />er</li> \n   <li>● javax.servlet.http.HttpSessionAttributeList<wbr />ener</li> \n   <li>● javax.faces.event.PhaseListener</li> \n  </ul> \n </div> \n <p><strong>State:</strong></p> \n <p>这个模式允许你可以在运行时很容易地根据自身内部的状态改变对象的行为。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Iterator</li> \n   <li>● javax.faces.lifecycle.LifeCycle#execute()</li> \n  </ul> \n </div> \n <p><strong>Strategy:</strong></p> \n <p>定义一组算法，并把其封装到一个对象中。然后在运行时，可以灵活的使用其中的一个算法。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Comparator#compare()</li> \n   <li>● javax.servlet.http.HttpServlet</li> \n   <li>● javax.servlet.Filter#doFilter()</li> \n  </ul> \n </div> \n <p><strong>Template method:</strong></p> \n <p>允许子类重载部分父类而不需要完全重写。</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● java.util.Collections#sort()</li> \n   <li>● java.io.InputStream#skip()</li> \n   <li>● java.io.InputStream#read()</li> \n   <li>● java.util.AbstractList#indexOf()</li> \n  </ul> \n </div> \n <p><strong>Visitor:</strong></p> \n <p>作用于某个对象群中各个对象的操作. 它可以使你在不改变这些对象本身的情况下,定义作用于这些对象的新操作.</p> \n <div style=\"margin-left: 4em\"> \n  <ul> \n   <li>● javax.lang.model.element.Element 和javax.lang.model.element.ElementVisitor</li> \n   <li>● javax.lang.model.type.TypeMirror 和javax.lang.model.type.TypeVisitor</li> \n  </ul> \n </div> \n <p>在stakeoverflow也有相应的讨论：</p> \n <p><a target=\"_blank\" href=\"http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns\"> http://stackoverflow.com/questions/1673841/examples-of-gof-design-patterns</a></p> \n <p>原文链接：http://coolshell.cn/articles/3320.html</p> \n</div>"},"date":{"text":"2010-11-29 17:55:14"}}