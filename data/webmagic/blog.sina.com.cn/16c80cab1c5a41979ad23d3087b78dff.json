{"title":{"text":"<h2 id=\"t_58ae76e80100l64u\" class=\"titName SG_txta\">[转载]java编译原理</h2>"},"content":{"text":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \"> \n <strong><a href=\"http://www.javaeye.com/blogs/category/java\" style=\"text-decoration: none; padding-right: 10px;\"></a></strong>\n <strong>Java编译原理：</strong>\n <br /> \n <div>\n  Java 虚拟机(JVM)是可运行Java 代码的假想计算机。只要根据JVM规格描述将解释器移植到特定的计算机上，就能保证经过编译的任何Java代码能够在该系统上运行。本文首先简要介绍从Java文件的编译到最终执行的过程，随后对JVM规格描述作一说明。\n  <br /> 　　\n  <br /> 　　一.Java源文件的编译、下载 、解释和执行\n  <br /> 　　Java应用程序的开发周期包括编译、下载 、解释和执行几个部分。Java编译程序将Java源程序翻译为JVM可执行代码?字节码。这一编译过程同C/C++ 的编译有些不同。当C编译器编译生成一个对象的代码时，该代码是为在某一特定硬件平台运行而产生的。因此，在编译过程中，编译程序通过查表将所有对符号的 引用转换为特定的内存偏移量，以保证程序运行。Java编译器却不将对变量和方法的引用编译为数值引用，也不确定程序执行过程中的内存布局，而是将这些符 号引用信息保留在字节码中，由解释器在运行过程中创立内存布局，然后再通过查表来确定一个方法所在的地址。这样就有效的保证了Java的可移植性和安全 性。\n  <br /> 　　\n  <br /> 　　运行JVM字节码的工作是由解释器来完成的。解释执行过程分三部进行：代码的装入、代码的校验和代码的执行。装入代码的工作由&quot;类装载器&quot; （class loader）完成。类装载器负责装入运行一个程序需要的所有代码，这也包括程序代码中的类所继承的类和被其调用的类。当类装载器装入一个类时，该类被放 在自己的名字空间中。除了通过符号引用自己名字空间以外的类，类之间没有其他办法可以影响其他类。在本台计算机上的所有类都在同一地址空间内，而所有从外 部引进的类，都有一个自己独立的名字空间。这使得本地类通过共享相同的名字空间获得较高的运行效率，同时又保证它们与从外部引进的类不会相互影响。当装入 了运行程序需要的所有类后，解释器便可确定整个可执行程序的内存布局。解释器为符号引用同特定的地址空间建立对应关系及查询表。通过在这一阶段确定代码的 内存布局，Java很好地解决了由超类改变而使子类崩溃的问题，同时也防止了代码对地址的非法访问。\n  <br /> 　　\n  <br /> 　　随后，被装入的代码由字节码校验器进行检查。校验器可发现操作数栈溢出，非法数据类型转化等多种错误。通过校验后，代码便开始执行了。\n  <br /> 　　\n  <br /> 　　Java字节码的执行有两种方式：\n  <br /> 　　1.即时编译方式：解释器先将字节码编译成机器码，然后再执行该机器码。\n  <br /> 　　2.解释执行方式：解释器通过每次解释并执行一小段代码来完成Java字节码程 序的所有操作。\n  <br /> 　　通常采用的是第二种方法。由于JVM规格描述具有足够的灵活性，这使得将字节码翻译为机器代码的工作\n  <br /> 　　\n  <br /> 　　具有较高的效率。对于那些对运行速度要求较高的应用程序，解释器可将Java字节码即时编译为机器码，从而很好地保证了Java代码的可移植性和高性能。\n  <br /> 　　\n  <br /> 　　二.JVM规格描述\n  <br /> 　　JVM的设计目标是提供一个基于抽象规格描述的计算机模型，为解释程序开发人员提很好的灵活性，同时也确保Java代码可在符合该规范的任何 系统上运行。JVM对其实现的某些方面给出了具体的定义，特别是对Java可执行代码，即字节码(Bytecode)的格式给出了明确的规格。这一规格包 括操作码和操作数的语法和数值、标识符的数值表示方式、以及Java类文件中的Java对象、常量缓冲池在JVM的存储 映象。这些定义为JVM解释器开发人员提供了所需的信息和开发环境。Java的设计者希望给开发人员以随心所欲使用Java的自由。\n  <br /> 　　\n  <br /> 　　JVM定义了控制Java代码解释执行和具体实现的五种规格，它们是：\n  <br /> 　　JVM指令系统\n  <br /> 　　JVM寄存器\n  <br /> 　　JVM栈结构\n  <br /> 　　JVM碎片回收堆\n  <br /> 　　JVM存储区\n  <br /> 　　\n  <br /> 　　2.1JVM指令系统\n  <br /> 　　\n  <br /> 　　JVM指令系统同其他计算机的指令系统极其相似。Java指令也是由 操作码和操作数两部分组成。操作码为8位二进制数，操作数进紧随在操作码的后面，其长度根据需要而不同。操作码用于指定一条指令操作的性质（在这里我们采 用汇编符号的形式进行说明），如iload表示从存储器中装入一个整数，anewarray表示为一个新数组分配空间，iand表示两个整数的&quot; 与&quot;，ret用于流程控制，表示从对某一方法的调用中返回。当长度大于8位时，操作数被分为两个以上字节存放。JVM采用了&quot;big endian&quot;的编码方式来处理这种情况，即高位bits存放在低字节中。这同 Motorola及其他的RISC CPU采用的编码方式是一致的，而与Intel采用的&quot;little endian &quot;的编码方式即低位bits存放在低位字节的方法不同。\n  <br /> 　　\n  <br /> 　　Java指令系统是以Java语言的实现为目的设计的，其中包含了用于调用方法和监视多先程系统的指令。Java的8位操作码的长度使得JVM最多有256种指令，目前已使用了160多种操作码。\n  <br /> 　　\n  <br /> 　　2.2JVM寄存器\n  <br /> 　　\n  <br /> 　　所有的CPU均包含用于保存系统状态和处理器所需信息的寄存器组。如果虚拟机定义较多的寄存器，便可以从中得到更多的信息而不必对栈或内存进 行访问，这有利于提高运行速度。然而，如果虚拟机中的寄存器比实际CPU的寄存器多，在实现虚拟机时就会占用处理器大量的时间来用常规存储器模拟寄存器， 这反而会降低虚拟机的效率。针对这种情况，JVM只设置了4个最为常用的寄存器。它们是：\n  <br /> 　　pc程序计数器\n  <br /> 　　optop操作数栈顶指针\n  <br /> 　　frame当前执行环境指针\n  <br /> 　　vars指向当前执行环境中第一个局部变量的指针\n  <br /> 　　所有寄存器均为32位。pc用于记录程序的执行。optop,frame和vars用于记录指向Java栈区的指针。\n  <br /> 　　\n  <br /> 　　2.3JVM栈结构\n  <br /> 　　\n  <br /> 　　作为基于栈结构的计算机，Java栈是JVM存储信息的主要方法。当JVM得到一个Java字节码应用程序后，便为该代码中一个类的每一个方法创建一个栈框架，以保存该方法的状态信息。每个栈框架包括以下三类信息：\n  <br /> 　　局部变量\n  <br /> 　　执行环境\n  <br /> 　　操作数栈\n  <br /> 　　\n  <br /> 　　局部变量用于存储一个类的方法中所用到的局部变量。vars寄存器指向该变量表中的第一个局部变量。\n  <br /> 　　执行环境用于保存解释器对Java字节码进行解释过程中所需的信息。它们是：上次调用的方法、局部变量指针和操作数栈的栈顶和栈底指针。执行 环境是一个执行一个方法的控制中心。例如：如果解释器要执行iadd(整数加法)，首先要从frame寄存器中找到当前执行环境，而后便从执行环境中找到 操作数栈，从栈顶弹出两个整数进行加法运算，最后将结果压入栈顶。\n  <br /> 　　操作数栈用于存储运算所需操作数及运算的结果。\n  <br /> 　　\n  <br /> 　　2.4JVM碎片回收堆\n  <br /> 　　\n  <br /> 　　Java类的实例所需的存储空间是在堆上分配的。解释器具体承担为类实例分配空间的工作。解释器在为一个实例分配完存储空间后，便开始记录对该实例所占用的内存区域的使用。一旦对象使用完毕，便将其回收到堆中。\n  <br /> 　　在Java语言中，除了new语句外没有其他方法为一对象申请和释放内存。对内存进行释放和回收的工作是由Java运行系统承担的。这允许 Java运行系统的设计者自己决定碎片回收的方法。在SUN公司开发的Java解释器和Hot Java环境中，碎片回收用后台线程的方式来执行。这不但为运行系统提供了良好的性能，而且使程序设计人员摆脱了自己控制内存使用的风险。\n  <br /> 　　\n  <br /> 　　2.5JVM存储区\n  <br /> 　　\n  <br /> 　　JVM有两类存储区：常量缓冲池和方法区。常量缓冲池用于存储类名称、方法和字段名称以及串常量。方法区则用于存储Java方法的字节码。对 于这两种存储区域具体实现方式在JVM规格中没有明确规定。这使得Java应用程序的存储布局必须在运行过程中确定，依赖于具体平台的实现方式。\n  <br /> 　　\n  <br /> 　　JVM是为Java字节码定义的一种独立于具体平台的规格描述，是Java平台独立性的基础。目前的JVM还存在一些限制和不足，有待于进一步的完善，但无论如何，JVM的思想是成功的。\n  <br /> 　　\n  <br /> 　　对比分析：如果把Java原程序想象成我们的C++ 原程序，Java原程序编译后生成的字节码就相当于C++原程序编译后的80x86的机器码（二进制程序文件），JVM虚拟机相当于80x86计算机系 统,Java解释器相当于80x86CPU。在80x86CPU上运行的是机器码，在Java解释器上运行的是Java字节码。\n  <br /> 　　\n  <br /> 　　Java解释器相当于运行Java字节码的“CPU”,但该“CPU”不是通过硬件实现的，而是用软件实现的。Java解释器实际上就是特定 的平台下的一个应用程序。只要实现了特定平台下的解释器程序，Java字节码就能通过解释器程序在该平台下运行，这是Java跨平台的根本。当前，并不是 在所有的平台下都有相应Java解释器程序，这也是Java并不能在所有的平台下都能运行的原因，它只能在已实现了Java解释器程序的平台下运行。\n  <br /> \n  <br /> \n  <br /> 本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/oyto12o/archive/2010/01/31/5274967.aspx\n </div> \n</div>"},"date":{"text":"2010-09-13 10:45:54"}}