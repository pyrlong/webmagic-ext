{"title":{"text":"<h2 id=\"t_58ae76e80100jty8\" class=\"titName SG_txta\">设计模式之观察者模式--理解设计模式的用处</h2>"},"content":{"text":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \">\n  &nbsp;\n <wbr /> 观察者模式其实我已经很熟悉了，因为一个课程作业就是要用观察者模式实现一个时钟，在服务器时钟更新时，需要多个客户端的时钟也更新。当时做这个作业基本是依葫芦画瓢，按照观察者模式的流程来做。但是以前写程序，是不大会考虑复用的，所以其实写完了也没明白这个模式的优秀之处在哪里。现在也算是写过了一个项目，就有了新的认知。\n <br /> &nbsp;\n <wbr /> 学生写的程序，写完了交给老师看就算是结束了，而真正一个项目是需要不断扩展的。复用可以减少冗余代码量，并且使修改变得容易；良好的扩展性则使扩展变得相对容易，而不是每次加一个功能都要修改核心代码。设计模式就可以解决这些事。\n <br /> &nbsp;\n <wbr /> 回到观察者模式，观察者模式有个很重要的概念：松耦合。\n <br /> 1、直接在Subject更新时就传递更新值给观察者让他们更新，与传递一个更新信息，然后让观察者自己去请求值，哪个更好？\n <br /> &nbsp;\n <wbr /> 这个问题当时想过。实际上两种方法各有优劣。push方法实现起来稍微简单，但是如果仅仅将所需参数写进去，就会有可扩展性的问题；解决方法是：将参数写入一个对象中，再将对象序列化后传过去。pull方法是通知更新后，由观察者自己来获取想要的数据，这样可扩展性很好，但是在pull的时候需要有一个认证，否则Subject的信息就可以被所有对象获取，这样是不安全的。\n <br /> 扩展不改变已有代码，这就是好的可扩展性。\n <br /> 2、Subject需要维护一个观察者表，然后每次更新时逐个调用其update。\n <br /> &nbsp;\n <wbr /> 这样也是为了不改变原有代码，将所有观察者写到一个表里而不是显示的挨个写在更新方法中。这个大概也是当时MB老师所说的Subject不能知道观察者都是谁的原因吧。\n <br /> \n</div>"},"date":{"text":"2010-07-12 13:19:16"}}