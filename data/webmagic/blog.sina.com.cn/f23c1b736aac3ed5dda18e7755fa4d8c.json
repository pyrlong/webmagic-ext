{"title":{"text":"<h2 id=\"t_58ae76e80100lseb\" class=\"titName SG_txta\">图解JVM在内存中申请对象及垃圾回收流程-转载</h2>"},"content":{"text":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \">\n  关键字: jvm 内存 gc \n <p>&nbsp;<wbr /></p> \n <p>&nbsp;<wbr /></p> \n <p><strong>先看一下JVM的内存模型：</strong></p> \n <p>&nbsp;<wbr /></p> \n <p><br /> <img src=\"http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif\" real_src=\"http://dl.javaeye.com/upload/attachment/145809/46ca5791-5c7f-365a-bb1c-171ddc03b5b5.png\" alt=\"\" title=\"图解JVM在内存中申请对象及垃圾回收流程-转载\" /><br /></p> \n <p>&nbsp;<wbr /></p> \n <p><strong>从大的方面来讲，JVM的内存模型分为两大块：</strong></p> \n <p>&nbsp;<wbr /></p> \n <p>永久区内存（ <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Permanent space</span></span> ）和堆内存（heap space）。</p> \n <p>&nbsp;<wbr /></p> \n <p>栈内存（stack space）一般都不归在JVM内存模型中，因为栈内存属于线程级别。</p> \n <p>每个线程都有个独立的栈内存空间。</p> \n <p>&nbsp;<wbr /></p> \n <p><span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Permanent space里存放加载的Class类级对象如class本身，method，field等等。</span></span></p> \n <p>heap space主要存放对象实例和数组。</p> \n <p>heap space由Old <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Generation和New</span></span> <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Generation组成，Old</span></span> <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Generation存放生命周期长久的实例对象，而新的对象实例一般放在New</span></span> <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Generation。</span></span></p> \n <p>New <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Generation还可以再分为Eden区(圣经中的伊甸园)、和Survivor区，新的对象实例总是首先放在Eden区，Survivor区作为Eden区和Old区的缓冲，可以向Old区转移活动的对象实例。<br /> </span></span></p> \n <p>&nbsp;<wbr /></p> \n <p><strong>下图是JVM在内存空间（堆空间）中申请新对象过程的活动图（点击看大图）：</strong><br /> <img title=\"点击查看原始大小图片\" src=\"http://simg.sinajs.cn/blog7style/images/common/sg_trans.gif\" real_src=\"http://dl.javaeye.com/upload/attachment/145805/2763425e-034b-3505-937a-f152d1a8fef6.jpg\" alt=\"\" height=\"707\" width=\"700\" /></p> \n <p>没错，我们常见的OOM（out of memory）内存溢出异常，就是堆内存空间不足以存放新对象实例时导致。</p> \n <p>&nbsp;<wbr /></p> \n <p> 永久区内存溢出相对少见，一般是由于需要加载海量的Class数据，超过了非堆内存的容量导致。通常出现在Web应用刚刚启动时，因此Web应用推荐使用预加载机制，方便在部署时就发现并解决该问题。</p> \n <p>&nbsp;<wbr /></p> \n <p>栈内存也会溢出，但是更加少见。</p> \n <p>&nbsp;<wbr /></p> \n <p><strong>堆内存优化：</strong></p> \n <p>调整JVM启动参数-Xms&nbsp;<wbr /> -Xmx &nbsp;<wbr /> -XX:newSize -XX:MaxNewSize，如调整初始堆内存和最大对内存 -Xms256M -Xmx512M。 或者调整初始New <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">Generation的初始内存和最大内存</span></span> -XX:newSize=128M -XX:MaxNewSize=128M。</p> \n <p>&nbsp;<wbr /></p> \n <p><strong>永久区内存优化：</strong></p> \n <p>调整PermSize参数&nbsp;<wbr />&nbsp;<wbr /> 如&nbsp;<wbr /> -XX:PermSize=256<span style=\"font-size: x-small;\">M</span> -XX:MaxPermSize=512M<span style=\"font-size: x-small;\">。</span></p> \n <p>&nbsp;<wbr /></p> \n <p><strong>栈内存优化：</strong></p> \n <p>调整每个线程的栈内存容量&nbsp;<wbr /> 如&nbsp;<wbr /> -Xss2048K</p> \n <p>&nbsp;<wbr /></p> \n <p>&nbsp;<wbr /></p> \n <span style=\"font-size: x-small;\">最终，一个运行中的JVM所占的内存= 堆内存&nbsp;<wbr /> +&nbsp;<wbr /> 永久区内存&nbsp;<wbr /> +&nbsp;<wbr /> 所有线程所占的栈内存总和</span> \n <span style=\"font-size: x-small;\"><span style=\"font-size: 10pt;\">。</span></span> \n</div>"},"date":{"text":"2010-10-16 11:20:46"}}