{"title":{"text":"<h2 id=\"t_58ae76e80100kbo7\" class=\"titName SG_txta\">基础中的基础-几种排序算法及分析</h2>"},"content":{"text":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \">\n  排序类别&nbsp;\n <wbr /> 时间复杂度&nbsp;\n <wbr /> 空间复杂度&nbsp;\n <wbr /> 稳定\n <br /> \n <br /> 1 插入排序&nbsp;\n <wbr /> O(n2)&nbsp;\n <wbr />&nbsp;\n <wbr /> 1&nbsp;\n <wbr />&nbsp;\n <wbr /> √\n <br /> \n <br /> 2 希尔排序&nbsp;\n <wbr /> O(n2)&nbsp;\n <wbr /> 1&nbsp;\n <wbr />&nbsp;\n <wbr /> &times;\n <br /> \n <br /> 3 冒泡排序 O(n2)&nbsp;\n <wbr />&nbsp;\n <wbr /> 1&nbsp;\n <wbr />&nbsp;\n <wbr /> √\n <br /> \n <br /> 4 选择排序&nbsp;\n <wbr /> O(n2)&nbsp;\n <wbr />&nbsp;\n <wbr /> 1&nbsp;\n <wbr />&nbsp;\n <wbr /> &times;\n <br /> \n <br /> 5 快速排序&nbsp;\n <wbr /> O(Nlogn) O(logn)&nbsp;\n <wbr /> &times;\n <br /> \n <br /> 6 堆排序&nbsp;\n <wbr /> O(Nlogn)&nbsp;\n <wbr /> 1&nbsp;\n <wbr />&nbsp;\n <wbr /> &times;\n <br /> \n <br /> 7 归并排序 O(Nlogn)&nbsp;\n <wbr /> O(n)&nbsp;\n <wbr />&nbsp;\n <wbr /> √\n <br /> \n <br /> 冒泡排序是稳定的，算法时间复杂度是O(n ^2)。\n <br /> \n <br /> 2.2 选择排序（Selection Sort）\n <br /> \n <br /> 选择排序的基本思想是对待排序的记录序列进行n-1遍的处理，第i遍处理是将L[i..n]中最\n <br /> 小者与L[i]交换位置。这样，经过i遍处理之后，前i个记录的位置已经是正确的了。\n <br /> \n <br /> 选择排序是不稳定的，算法复杂度是O(n ^2 )。\n <br /> \n <br /> 2.3 插入排序 （Insertion Sort）\n <br /> \n <br /> 插入排序的基本思想是，经过i-1遍处理后,L[1..i-1]己排好序。第i遍处理仅将L[i]插入\n <br /> L[1..i-1]的适当位置，使得L[1..i] 又是排好序的序列。要达到这个目的，我们可以用顺\n <br /> 序比较的方法。首先比较L[i]和L[i-1]，如果L[i-1]≤ L[i]，则L[1..i]已排好序，第i遍\n <br /> 处理就结束了；否则交换L[i]与L[i-1]的位置，继续比较L[i-1]和L[i-2]，直到找到某一\n <br /> 个位置j(1≤j≤i-1)，使得L[j] ≤L[j+1]时为止。图1演示了对4个元素进行插入排序的过\n <br /> 程，共需要(a),(b),(c)三次插入。\n <br /> \n <br /> 直接插入排序是稳定的，算法时间复杂度是O(n ^2) 。\n <br /> \n <br /> 2.4 堆排序\n <br /> \n <br /> 堆排序是一种树形选择排序，在排序过程中，将A[n]看成是完全二叉树的顺序存储结构，\n <br /> 利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。\n <br /> \n <br /> 堆排序是不稳定的，算法时间复杂度O(nlog n)。\n <br /> \n <br /> 2.5 归并排序\n <br /> \n <br /> 设有两个有序（升序）序列存储在同一数组中相邻的位置上，不妨设为A[l..m]，A[m+1..\n <br /> h]，将它们归并为一个有序数列，并存储在A[l..h]。\n <br /> \n <br /> 其时间复杂度无论是在最好情况下还是在最坏情况下均是O(nlog2n)。\n <br /> \n <br /> 2.6 快速排序\n <br /> \n <br /> 快速排序是对冒泡排序的一种本质改进。它的基本思想是通过一趟扫描后，使得排序序列\n <br /> 的长度能大幅度地减少。在冒泡排序中，一次扫描只能确保最大数值的数移到正确位置，\n <br /> 而待排序序列的长度可能只减少1。快速排序通过一趟扫描，就能确保某个数（以它为基准\n <br /> 点吧）的左边各数都比它小，右边各数都比它大。然后又用同样的方法处理它左右两边的\n <br /> 数，直到基准点的左右只有一个元素为止。\n <br /> \n <br /> 快速排序是不稳定的，最理想情况算法时间复杂度O(nlog2n)，最坏O(n ^2)。\n <br /> \n <br /> 2.7 希尔排序\n <br /> \n <br /> 在直接插入排序算法中，每次插入一个数，使有序序列只增加1个节点，并且对插入下一个\n <br /> 数没有提供任何帮助。如果比较相隔较远距离（称为增量）的数，使得数移动时能跨过多\n <br /> 个元素，则进行一次比较就可能消除多个元素交换。D.L.shell于1959年在以他名字命名的\n <br /> 排序算法中实现了这一思想。算法先将要排序的一组数按某个增量d分成若干组，每组中记\n <br /> 录的下标相差d.对每组中全部元素进行排序，然后再用一个较小的增量对它进行，在每组\n <br /> 中再进行排序。当增量减到1时，整个要排序的数被分成一组，排序完成。\n <br /> \n <br /> 希尔排序是不稳定的，其时间复杂度为O(n ^2)。\n <br /> \n</div>"},"date":{"text":"2010-07-28 09:10:57"}}