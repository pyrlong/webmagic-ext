{"title":{"text":"<h2 id=\"t_58ae76e80100ljeh\" class=\"titName SG_txta\">设计模式小结</h2>"},"content":{"text":"<div id=\"sina_keyword_ad_area2\" class=\"articalContent  \">\n  创建型模式\n <br /> 生成器模式(Builder Method)：用一个对象的方法及已有信息构造一个新对象。\n <br /> 工厂方法(Factory Method)：定义一个创建对象的接口，子类可以用不同的实现创建不同的对象。\n <br /> 抽象工厂(Abstact Factory)：提供一个接口，用于创建一系列相关的对象，不需制定具体类。\n <br /> 原型模式(Prototype)：用原型实例制定创建对象的种类，并且通过拷贝这些原形创建新的对象。\n <br /> 单例模式(Singleton)：只允许存在一个关于某类的实例。在第一次调用时创建以节约资源。\n <br /> \n <br /> 结构型模式：\n <br /> 适配器模式(Adapter)：将一个类的接口转变为用户期望的另一个接口。\n <br /> 外观模式(Facade)：提供一个统一的接口来访问子系统的一系列接口。JOptionPane :showConfirmPane\n <br /> 桥接模式(Bridge)：将抽象和实现分离，并且用这两种对象共同的方法构成抽象和实现的“桥”。\n <br /> 模板方法(Template Method)：一个算法定义一系列方法步骤，有的没有实现，子类实现这些步骤从而实现不同的算法。\n <br /> 装饰器模式(Decrator)：动态的将功能加到对象上，比继承更有弹性，并且不会造成继承类的组合爆炸。\n <br /> 状态模式(State)：将对象的状态以及状态下对应的操作封装成一个接口，并用不同具体类实现。\n <br /> 命令模式(Command)：将请求封装成一个接口，并用不同具体类实现，每个操作有撤销功能，可用于日志记录等。\n <br /> 组合模式(Composite)：将对象的组合成树形结构，使得用户对单个对象和组合的使用具有一致性。\n <br /> \n <br /> \n <br /> 行为模式：\n <br /> 策略模式(Stategy)：将变化的部分方法用一个接口封装起来，并用不同具体类实现。\n <br /> 迭代器模式(Iterator)：使用一个迭代器访问一个对象集合的，从而可以不用管集合的具体实现。\n <br /> 解释器模式(Interpreter)：给定一个语言，定义它的文法表示与解释器，从而实现可扩展的描述问题。\n <br /> 访问者模式(Visitor)：定义一个在集合元素上进行的操作，从而达到不改变元素就修改操作的目的。\n <br /> 观察者模式(Observer)：对象间的一对多依赖，当一个对象改变时，所有依赖者会被通知并自动更新。\n <br /> 中介者模式(Mediator)：用一个中介对象来封装一系列对象间的交互。从而对象只需知道中介者不需知道彼此。\n <br /> 备忘录(Memento)：捕获一个对象的内部状态并在对象之外保存，这样在之后就可以将这个对象恢复到原先保存的状态。\n <br /> 代理模式(Proxy)：用一个对象提供另一个对象访问的“门”，对用户隐藏他们的区别。用处：占位（RMI中的远程代理stub）访问控制。\n <br /> 责任链模式(Chain of Responsbility)：将请求的处理者处理成一个动态的链，一条请求可以一直在链中传递直到被处理。避免了请求的发送者和接受者直接的耦合关系。\n <br /> 享元模式(Flyweight)；运用共享技术有效地支持大量细粒度的对象。\n <br /> \n <br /> \n</div>"},"date":{"text":"2010-10-04 19:22:53"}}